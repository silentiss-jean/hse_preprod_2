#!/usr/bin/env python3
from __future__ import annotations

import argparse
import json
import re
from pathlib import Path


MANIFEST_REL = "themes/themes.manifest.json"

PATCH_START = "/* HSE_PHASE2_PATCH_START */"
PATCH_END = "/* HSE_PHASE2_PATCH_END */"


def read_text(p: Path) -> str:
    return p.read_text(encoding="utf-8", errors="replace")


def write_text(p: Path, txt: str) -> None:
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text(txt, encoding="utf-8")


def extract_themes_from_registry(js_text: str) -> list[dict]:
    """
    Extract objects inside `export const THEMES = [ ... ];`
    This is a pragmatic parser: good enough for stable formatting.
    """
    m = re.search(r"export\s+const\s+THEMES\s*=\s*\[(.*?)\]\s*;", js_text, re.S)
    if not m:
        raise RuntimeError("Cannot find `export const THEMES = [ ... ];` in themesRegistry.js")

    block = m.group(1)

    # Split top-level objects by "}," boundaries (tolerant).
    raw_objs = re.split(r"\}\s*,", block)
    themes = []
    for raw in raw_objs:
        raw = raw.strip()
        if not raw:
            continue
        if not raw.endswith("}"):
            raw = raw + "}"

        def get_str(key: str) -> str | None:
            mm = re.search(rf"{key}\s*:\s*\"([^\"]*)\"", raw)
            return mm.group(1) if mm else None

        def get_bool(key: str) -> bool | None:
            mm = re.search(rf"{key}\s*:\s*(true|false)", raw)
            return (mm.group(1) == "true") if mm else None

        t = {
            "id": get_str("id"),
            "key": get_str("key"),
            "label": get_str("label"),
            "description": get_str("description"),
            "icon": get_str("icon"),
            "default": get_bool("default") or False,
        }
        if not t["id"] or not t["key"]:
            # Skip malformed entries
            continue
        themes.append(t)

    return themes


def build_manifest(themes: list[dict], max_themes: int = 10) -> dict:
    themes = themes[:max_themes]
    return {
        "max_themes": max_themes,
        "notes": "Auto-generated by Phase 2 script (manifest source of truth).",
        "themes": themes,
    }


def upsert_manifest(manifest_path: Path, manifest: dict, dry_run: bool) -> bool:
    if manifest_path.exists():
        current = json.loads(read_text(manifest_path))
        # Keep user's future custom fields if any; but replace main keys.
        merged = dict(current)
        merged["max_themes"] = manifest["max_themes"]
        merged["themes"] = manifest["themes"]
        merged.setdefault("notes", manifest.get("notes"))
        new_txt = json.dumps(merged, ensure_ascii=False, indent=2) + "\n"
    else:
        new_txt = json.dumps(manifest, ensure_ascii=False, indent=2) + "\n"

    if dry_run:
        return True
    write_text(manifest_path, new_txt)
    return True


def patch_registry_for_manifest(js_text: str, manifest_rel: str) -> str:
    """
    Insert (or replace) a patch block that:
    - loads manifest
    - exports THEMES from manifest
    - applyTheme(key) -> sets document.documentElement.dataset.theme
    - persists to localStorage
    """
    patch = f"""{PATCH_START}
const THEME_STORAGE_KEY = "hse_theme_key";

async function loadThemeManifest() {{
  const url = "{manifest_rel}";
  const res = await fetch(url, {{ cache: "no-store" }});
  if (!res.ok) throw new Error(`Theme manifest not found: ${{url}} (${{res.status}})`);
  return res.json();
}}

function setThemeOnDom(themeKey) {{
  // Phase 2 choice: data-theme (not body class) [audit plan]
  document.documentElement.dataset.theme = themeKey || "";
}}

export async function initThemes() {{
  const manifest = await loadThemeManifest();
  const themes = Array.isArray(manifest.themes) ? manifest.themes : [];
  // expose as live export by mutating array content
  THEMES.length = 0;
  themes.forEach((t) => THEMES.push(t));

  const stored = localStorage.getItem(THEME_STORAGE_KEY);
  const defaultTheme = themes.find((t) => t.default) || themes[0];
  const chosen = themes.find((t) => t.key === stored) || defaultTheme;
  if (chosen) {{
    applyTheme(chosen.key);
  }}
}}

export function applyTheme(themeKey) {{
  if (themeKey) {{
    localStorage.setItem(THEME_STORAGE_KEY, themeKey);
  }}
  setThemeOnDom(themeKey);
}}
{PATCH_END}
"""

    # Ensure we have a mutable exported array called THEMES:
    # If `export const THEMES = [...]` exists, replace RHS with `[]`.
    js_text2 = re.sub(
        r"export\s+const\s+THEMES\s*=\s*\[(.*?)\]\s*;",
        "export const THEMES = [];",
        js_text,
        flags=re.S,
        count=1,
    )

    # Insert/replace patch block
    if PATCH_START in js_text2 and PATCH_END in js_text2:
        start = js_text2.find(PATCH_START)
        end = js_text2.find(PATCH_END, start) + len(PATCH_END)
        return js_text2[:start] + patch + js_text2[end:]

    # Append patch at end
    if not js_text2.endswith("\n"):
        js_text2 += "\n"
    return js_text2 + "\n" + patch


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--root", required=True, help="Path to web_static/")
    ap.add_argument("--themes-registry", default="themesRegistry.js", help="themesRegistry.js path relative to root")
    ap.add_argument("--manifest", default=MANIFEST_REL, help="Manifest path relative to root")
    ap.add_argument("--max-themes", type=int, default=10, help="Max themes (plan says 10)")
    ap.add_argument("--dry-run", action="store_true")
    args = ap.parse_args()

    root = Path(args.root).resolve()
    registry_path = (root / args.themes_registry).resolve()
    manifest_path = (root / args.manifest).resolve()

    if not registry_path.exists():
        raise SystemExit(f"themesRegistry not found: {registry_path}")

    js = read_text(registry_path)
    themes = extract_themes_from_registry(js)

    if len(themes) == 0:
        raise SystemExit("No themes extracted from themesRegistry.js")

    manifest = build_manifest(themes, max_themes=args.max_themes)
    upsert_manifest(manifest_path, manifest, dry_run=args.dry_run)

    patched = patch_registry_for_manifest(js, args.manifest.replace("\\", "/"))

    if args.dry_run:
        print("== phase2 dry-run ==")
        print(f"root: {root}")
        print(f"registry: {registry_path}")
        print(f"manifest: {manifest_path}")
        print(f"themes_extracted: {len(themes)}")
        print("registry would be patched:", patched != js)
        return 0

    write_text(registry_path, patched)
    print("== phase2 applied ==")
    print(f"manifest written: {manifest_path}")
    print(f"themesRegistry patched: {registry_path}")
    print(f"themes in manifest: {len(manifest['themes'])}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
